(* Global flags *)

functor Flags (structure Crash : CRASH
	       structure Report : REPORT) : FLAGS =
  struct

    val change_to_force_recompilation = 1

    structure NewList = List
    structure ListPair = Edlib.ListPair
    structure List = Edlib.List

    val debug_print = print

    fun outLine (s) = print(s ^ "\n")

    fun quote s = "\"" ^ String.toString s ^ "\""
	
    fun die s = Crash.impossible ("Flags." ^ s)

     (* To introduce a new dynamic flag, do the following:

            Use the function add_flag_to_menu from within a module.

        OR

        (a) declare a new boolean reference, r
        (b) add r to the menu (with a menu text) at an appropriate place
        (c) add r to the `Adding initial entries' section below, together with 
	    a search key (a string), which can be used by the modules that 
            want to access the flag.
        (d) recompile this functor and the functor which uses the new flag

     *)

     
    (* Pretty Printing *)

    val raggedRight = ref true

    (* Debugging Flags *)
    val DEBUG_LEXING       = ref false
    val DEBUG_PARSING      = ref false
    val DEBUG_ELABDEC      = ref false
    val DEBUG_ELABTOPDEC   = ref false
    val DEBUG_ENVIRONMENTS = ref false
    val DEBUG_ERRORPRINT   = ref false
    val DEBUG_EVALDEC      = ref false
    val DEBUG_EVALTOPDEC   = ref false
    val DEBUG_FLEXRECORDS  = ref false
    val DEBUG_STATOBJECTS  = ref false
    val DEBUG_TYPES        = ref false
    val DEBUG_TYVARS       = ref false
    val print_type_name_stamps = ref false

    val DEBUG_REFOBJECTS   = ref false
    val DEBUG_REFDEC       = ref false
    val DEBUG_SORTS	   = ref false (* true *)
    val DEBUG_SORTVARS	   = ref false
    val PRINT_DATASORT_PROGRESS = ref (*false*) true

    (* For Sorted SML.  *)
    val allow_noncovariant_refinements = ref true
(*    val add_unions_to_constructor_sorts = ref true    [now in RefinedEnvironments] *)

    val load_prelude = ref true (* false *)

   (*Compiler debug options: *)
    val DEBUG_COMPILER          = ref false
    val DEBUG_DECISIONTREE      = ref false
    val DEBUG_MATCHCOMPILER     = ref false
    val DEBUG_OPTIMISER         = ref false

    val optimiser               = ref true
    val type_check_lambda       = ref true
          (*don't change 29/03/1997 17:35. tho.*)

    (* Elimination of polymorphic equality *)
    val eliminate_polymorphic_equality = ref true

    val unbox_datatypes         = ref true
    val tag_integers            = ref false
    val tag_values              = ref false

   (* Region inference debug options *)

    val DEBUG_REGIONINFERENCE =  ref false
    val print_effects = ref false
    val print_regions = ref true
    val print_word_regions = ref false
    val print_types  = ref false
    val warn_on_escaping_puts = ref false
    val all_multiplicities_infinite = ref false   
    (* attop/atbot inference *)

    (* Optimiser *)
    val statistics_after_optimisation = ref false
    val minimize_fixs = ref true
    val fix_conversion = ref true
    val contract = ref true
    val specialize_recursive_functions = ref true
    val eliminate_explicit_records = ref true
    val maximum_inline_size = ref 20            
    val maximum_specialise_size = ref 200

    (* Printing of intermediate forms *)
    val print_opt_lambda_expression = ref false
    val print_attop_atbot_expression = ref false
    val print_drop_regions_expression = ref false
    val print_drop_regions_expression_with_storage_modes = ref false
    val print_physical_size_inference_expression = ref false
    val print_call_explicit_expression = ref false

    val disable_atbot_analysis = ref false
    val print_K_normal_forms = ref false
    val debug_which_at = ref false
    val enhanced_atbot_analysis = ref false

    (* Flags for region profiling. *)
    val region_profiling = ref false
    val show_region_flow_graph = ref false
    val print_all_program_points = ref true
    val program_points = (ref []): int list ref
    val region_paths = (ref[]): (int*int) list ref

    val chat                    = ref false
    val delay_assembly          = ref false   
    val log_to_file = ref false
    val target_file_extension = ref ".s" (*or ".c", with the C back end*)

    (*The following four have to do with the compilation of the C or the
     HP PA-RISC code generated by the kit.  (The kit will compile
     your ml program all the way to an executable by using a
     C compiler.)  These ref's are used in Manager/Manager.sml.*)

    val path_to_runtime = ref "You_did_not_set_path_to_runtime"
    val path_to_runtime_prof = ref "You_did_not_set_path_to_runtime_prof"

    val c_compiler = ref "gcc" (*or maybe "gcc -ansi" or "cc -Aa" *)
    val c_libs = ref "-lm" (*include math lib when compiling target code from the kit*)

    val kit_backend = ref "C" (*either "C" or "native"*)

    val colwidth               = ref 100

    val log        = ref TextIO.stdOut

    val indent_ccode   = ref false;

    (* Program manager *)

    fun dummy _ : unit = print "uninitialised function reference in Flags!"
    val project_file_name = ref "sources.pm"
    val build_project_ref: (string -> unit)ref = ref dummy
    val comp_ref: (string -> unit)ref  = ref dummy
    val current_source_file = ref "dummy"
    val auto_import_basislib = ref true
    val basislib_project = ref "You_did_not_set_basislib_project"

    val timings_stream : TextIO.outstream option ref = ref NONE

    (* Garbage Collection *)
           
    val garbage_collection = ref true

    (* deletion of linkable files *)

    val delete_target_files = ref true


          (*************************************************)
          (*                                               *)
          (*                   warnings                    *)
          (*                                               *)
          (*************************************************)


    type Report = Report.Report

    local val warnings : Report list ref = ref [];
    in
      fun reset_warnings () = warnings := []

      fun warn report = warnings := report :: !warnings
      val warn_string = warn o Report.line

      fun get_warned () = case (!warnings) of [] => false | _::_ => true 

      fun report_warnings () = 
	    (case !warnings of
	       [] =>  ()
	     | reports =>
		 (if !log_to_file then
		    print ("\n*** " ^ Int.toString (NewList.length reports)
			   ^ " warning"
			   ^ (case reports of [_] => "" | _ => "s")
			   ^ " printed on log file\n")
		  else ();
		  let val reports = rev reports
		      val report = Report.//
			            (Report.line "\n ***************** Warnings *****************\n",
				     Report.flatten reports)
		  in Report.print' report (!log)
		  end))
    end (*local*)


    (* -----------------------------------
     *         Parse functions 
     * ----------------------------------- *)

   type ('a, 'b) reader = ('a, 'b) StringCvt.reader

    fun scan_comma (getc : (char,'cs) reader) (cs:'cs) : 'cs option =
      case getc (StringCvt.skipWS getc cs)
	of SOME(#",",cs) => SOME cs
	 | _ => NONE

    fun scan_endlist (getc : (char,'cs)reader) (cs:'cs) (acc : 'a list) : ('a list * 'cs)option =
      let val cs = StringCvt.skipWS getc cs
      in case getc cs
	   of SOME(#"]",cs) => SOME (rev acc,cs)
	    | _ => NONE
      end

    fun scan_list scan_elem getc cs =
      let val cs = StringCvt.skipWS getc cs
	  fun loop(cs,acc) =
	    case scan_comma getc cs
	      of SOME cs => 
		(case scan_elem getc cs
		   of SOME(e,cs) => loop(cs,e::acc)
		    | NONE => NONE)
	       | NONE => scan_endlist getc cs acc
      in case getc cs
	   of SOME(#"[",cs) => 
	     (case scan_elem getc cs
		of SOME(e,cs) => loop(cs, [e])
		 | NONE => scan_endlist getc cs [])
	    | _ => NONE
      end

    fun scan_pair scan1 scan2 getc cs =
      case getc (StringCvt.skipWS getc cs)
	of SOME(#"(",cs) => 
	  (case scan1 getc cs
	     of SOME(e1,cs) =>
	       (case getc (StringCvt.skipWS getc cs)
		  of SOME(#",",cs) => 
		    (case scan2 getc (StringCvt.skipWS getc cs)
		       of SOME(e2,cs) => 
			 (case getc (StringCvt.skipWS getc cs)
			    of SOME(#")",cs) => SOME((e1,e2),cs)
			     | _ => NONE)
			| NONE => NONE)
		   | _ => NONE)
	      | NONE => NONE)
	 | _ => NONE

    fun scan_string getc cs =
      let fun loop (cs, acc) =
	    case getc cs
	      of SOME(#"\"", cs) => SOME(implode(rev acc),cs)
	       | SOME(c,cs) => loop(cs,c::acc)
	       | NONE => NONE
      in case getc (StringCvt.skipWS getc cs)
	   of SOME(#"\"", cs) => loop(cs, [])
	    | _ => NONE
      end

    fun getc [] = NONE
      | getc (c::cs) = SOME(c,cs)



          (*************************************************)
          (*           structure ParseScript               *)
          (*                                               *)
          (* Parsing settings (filenames and directories)  *)
          (* from a script file                            *)
          (*************************************************)

structure ParseScript: sig 
			 datatype const = INT of int | STRING of string | BOOL of bool
			 exception ParseScript of string
			 val parseScript : string -> (string * const) list 
		       end =

  (* syntax: 

     DEC::= val ID : TYPE  = CONST REST 
     REST::= ;
         |  DEC
     ID  ::= sequence_of_letters_underbars_and_primes
     TYPE::= int | string | bool
     CONST::= ml_integer_constant | ml_string_constant | ml_bool_constant
  
     blanks, tabs and newlines are separators;
     comments are enclosed in (* and *) and can be nested.
  *)

struct
  datatype ty = Int | String | Bool
  datatype const = INT of int | STRING of string | BOOL of bool
  type parse_result = (string * const) list
  type state  = string list * parse_result 
  type parser = state -> state
  exception ParseScript of string

  fun scan_token getc cs = 
    let val cs = StringCvt.skipWS getc cs
        fun loop (cs, acc) =
          case getc cs
	    of SOME (c,cs') => if Char.isAlphaNum c orelse c= #"_" orelse c= #"'" then loop(cs',c::acc)
			       else SOME(implode (rev acc), cs)  
	     | NONE => if acc=nil then NONE else SOME(implode(rev acc),cs)
    in loop (cs, [])
    end

  fun scan_id getc cs = 
    case scan_token getc cs
      of SOME res => res
       | NONE => raise ParseScript "I expect an identifier"

  fun scan_ty getc cs =
    let val cs = StringCvt.skipWS getc cs
    in case scan_token getc cs
	 of SOME("int",cs) => (Int,cs)
	  | SOME("string",cs) => (String,cs)
	  | SOME("bool",cs) => (Bool,cs)
	  | _ => raise ParseScript "I expect one of `int', `string', or `bool'"
    end

  fun scan_colon getc cs =
    let val cs = StringCvt.skipWS getc cs
    in case getc cs
	 of SOME(#":", cs) => cs
	  | _ => raise ParseScript "I expect `:'"
    end

  fun scan_eq getc cs =
    let val cs = StringCvt.skipWS getc cs
    in case getc cs
	 of SOME(#"=", cs) => cs
	  | _ => raise ParseScript "I expect `='"
    end

  fun scan_val getc cs =
    case scan_token getc cs
      of SOME("val",cs) => SOME cs
       | _ => NONE

  fun scan_dec getc cs =
    case scan_val getc cs
      of SOME cs =>
	let val (id, cs) = scan_id getc cs
	    val cs = scan_colon getc cs
	    val (ty, cs) = scan_ty getc cs
	    val cs = scan_eq getc cs
	    val (const, cs) =
	      case ty
		of Int => (case Int.scan StringCvt.DEC getc cs
			     of SOME(i,cs) => (INT i,cs)
			      | NONE => raise ParseScript "I expect an integer constant")
		 | String => (case scan_string getc cs
				of SOME(s,cs) => (STRING s,cs)
				 | NONE => raise ParseScript "I expect a string constant")
		 | Bool => (case Bool.scan getc cs
			      of SOME(b,cs) => (BOOL b,cs)
			       | NONE => raise ParseScript "I expect a bool constant")
	in SOME((id,const),cs)
	end
       | NONE => NONE

  fun scan_decs getc cs =
    case scan_dec getc cs
      of SOME(dec,cs) =>
	let val decs = scan_decs getc cs
	in dec::decs
	end
       | NONE => 
	let val cs = StringCvt.skipWS getc cs
	in case getc cs
	     of SOME (#";", cs) => scan_decs getc cs
	      | SOME _ => raise ParseScript "I expect `;' or `val' or `end of file'"
	      | NONE => []
	end
  
  fun drop_comments (l: char list) : char list =
    let fun loop(n, #"(" :: #"*" :: rest ) = loop(n+1, rest)
          | loop(n, #"*" :: #")" :: rest ) = loop(n-1, if n=1 then #" "::rest else rest)
          | loop(0, ch ::rest) = ch :: loop (0,rest)	  
          | loop(0, []) = []
          | loop(n, ch ::rest) = loop(n,rest)
          | loop(n, []) = raise ParseScript "unclosed comment"
    in
        loop(0,l)
    end;
  
  fun fromFile filename =
    let val is = TextIO.openIn filename 
        val s = TextIO.inputAll is handle E => (TextIO.closeIn is; raise E)
    in TextIO.closeIn is; s
    end

  fun parseScript(filename: string) = 
    ((scan_decs getc (drop_comments(explode(fromFile filename))))
     handle IO.Io {name,function,...} => raise ParseScript (name ^":"^function))
    handle ParseScript s => (TextIO.output(!log, "\n *parse error*: " ^ s ^ "\n");
			     raise ParseScript s)

end (* ParseScript *)


           
          (**************************************************)
          (*           structure Directory                  *)
          (*                                                *)
          (* Directory, holding associations for            *)
	  (* various settings and operations for toggling,  *)
	  (* etc. Also, readScript is here.                 *)
          (**************************************************)

structure Directory : sig
                        type state
			val get_state           : unit -> state
			val reset_state         : state -> unit
			val is_on               : string -> bool 
			val turn_on             : string -> unit
			val turn_off            : string -> unit
			val add_string_entry    : string * string ref -> unit
			val add_int_entry       : string * int ref -> unit
			val add_bool_entry      : string * bool ref -> unit
			val get_string_entry    : string -> string
			val lookup_string_entry : string -> string ref
			val lookup_flag_entry   : string -> bool ref
			val lookup_int_entry    : string -> int ref
			val readScript          : string -> unit
			val show_script_entries : unit -> unit
		      end =
struct

  (* Directory for dynamic flags. *)  
  type directory = {strings: (string*string ref) list ref,
                    integers: (string*int ref) list ref,
		    booleans: (string*bool ref) list ref};
  val dir = {strings = ref [], integers = ref [], booleans = ref []} : directory

  (* Make it possible to get and set a state. *)
  type state = {strings:  (string*string ref) list,
		integers: (int*int ref) list,
		booleans: (bool*bool ref) list}

  fun get_state () : state =
    {strings  = List.map (fn (_,str_ref)  => (!str_ref, str_ref))  (!(#strings dir)),
     integers = List.map (fn (_,int_ref)  => (!int_ref, int_ref))  (!(#integers dir)),
     booleans = List.map (fn (_,bool_ref) => (!bool_ref, bool_ref)) (!(#booleans dir))}

  fun reset_state ({strings, integers, booleans} : state) =
    let
      fun update (x, x_ref) = x_ref := x
    in
      (NewList.app update strings;
       NewList.app update integers;
       NewList.app update booleans)
    end

  (* Toggles and check for boolean flags. *)
  fun lookup_entry subdir key =
    case NewList.find (fn (key':string,_) => key=key') (!subdir)
      of SOME res => #2 res
       | NONE => die ("lookup_entry " ^ key)

  fun lookup_flag_entry key = lookup_entry (#booleans dir) key
  fun lookup_string_entry key = lookup_entry (#strings dir) key
  fun lookup_int_entry key = lookup_entry (#integers dir) key
  val get_string_entry = ! o lookup_string_entry
  val is_on = ! o lookup_flag_entry
  fun turn_on (key: string) : unit = lookup_flag_entry key := true
  fun turn_off (key: string) : unit = lookup_flag_entry key := false

  (* Functions for adding an entry to the directory. *)
  local
    fun add_entry([], key, r) = [(key,r)]
      | add_entry((key',r')::rest,key,r) = if key=key' then (key,r)::rest
					   else (key',r')::add_entry(rest, key, r) 
  in
    fun add_string_entry(key,r) = #strings dir := add_entry(!(#strings dir),key,r)
    fun add_int_entry(key,r) = #integers dir := add_entry(!(#integers dir),key,r)
    fun add_bool_entry(key,r) = #booleans dir := add_entry(!(#booleans dir),key,r)
  end



  (* Read and interpret script and update directory according to 
   * parse result. *)
  local
    fun update_assoc([], key,_) = print("Cannot find script key: " ^ key ^ "\n")
      | update_assoc((key',r)::rest, key, value) = 
      if key=key' then r:= value else update_assoc(rest, key, value);

    fun update_string(key, value) = update_assoc(!(#strings dir), key, value);
    fun update_int(key, value) = update_assoc(!(#integers dir), key, value);
    fun update_bool(key, value) = update_assoc(!(#booleans dir), key, value);

    fun interpret (l:(string*ParseScript.const) list) : unit = 
      NewList.app (fn (s, ParseScript.STRING newval) => update_string(s,newval)
                    | (s, ParseScript.INT newval) => update_int(s,newval)
                    | (s, ParseScript.BOOL newval) => update_bool(s,newval)) l;
  in
    fun readScript script_file : unit = 
      if OS.FileSys.access (script_file, []) then
	    (print ("Reading script file " ^ quote script_file ^ "\n");
	     interpret (ParseScript.parseScript script_file) 
	     handle _ => print ("Error while reading script file\n"))
      else print ("No script file " ^ quote script_file ^ " present\n")
  end

  (* Write all possible entries which can be changed from *)
  (* the script file.                                     *)
  fun show_script_entries () =
    let
      val dirEntriesName = (List.map #1 (!(#strings (dir)))) @ 
	                   (List.map #1 (!(#integers (dir)))) @ 
			   (List.map #1 (!(#booleans (dir))))

      val dirEntriesValue = (List.map (! o #2) (!(#strings (dir)))) @ 
                            (List.map (Int.toString o ! o #2) (!(#integers (dir)))) @ 
			    (List.map (Bool.toString o ! o #2) (!(#booleans (dir))))
      
      fun calc_width w [] = w
	| calc_width w (s::xs) = 
	    if w < (String.size s) then
	      calc_width (String.size s) xs
	    else
	      calc_width w xs

      val column_width = calc_width 0 (dirEntriesName @ dirEntriesValue)

      fun make_field s = StringCvt.padRight #" " column_width s
      
      val horizontal_column_line = StringCvt.padRight #"-" column_width ""
      fun horizontal_line 0 res = res ^ "+"
	| horizontal_line n res = horizontal_line (n-1) (res ^ "+" ^ horizontal_column_line)
      
      fun make_row [] s = s ^ "|"
	| make_row (x::xs) s = make_row xs (s ^ "|" ^ (make_field x))
      
    in
      (outLine (horizontal_line 2 "");
       outLine (make_row ["Name to use in script file", "Value of variable now"] "");
       outLine (horizontal_line 2 "");
       map (fn  (name, value) => outLine (make_row [name, value] ""))
       (ListPair.zip (dirEntriesName, dirEntriesValue))
           handle ListPair.Zip => die "zip" ;
       outLine (horizontal_line 2 ""))
    end

  (* Adding initial entries. *)
  val _ = NewList.app add_string_entry
        [("path_to_runtime", path_to_runtime), 
	 ("path_to_runtime_prof", path_to_runtime_prof),
	 ("c_compiler", c_compiler),  (*e.g. "cc -Aa" or "gcc -ansi"*)
	 ("c_libs", c_libs),  (*e.g. "-lm"*)
	 ("target_file_extension", target_file_extension),  (*e.g. ".c" or ".s"*)
	 ("path_to_kit_script", ref "you-did-not-set-path-to-kit-script"), 
	 ("kit_backend", kit_backend)] (*either "C" or "native"*)

  val _ = NewList.app add_int_entry
        [("colwidth", colwidth),
	 ("maximum_inline_size", maximum_inline_size),
	 ("maximum_specialise_size", maximum_specialise_size)]

  val _ = NewList.app add_bool_entry (* MEMO: Not all flags added...  (martin) *)
    [("type_check_lambda",type_check_lambda),
     ("delete_target_files",delete_target_files),
     ("unbox_datatypes", unbox_datatypes),
     ("tag_integers", tag_integers),
     ("tag_values", tag_values), 
     ("statistics_after_optimisation", statistics_after_optimisation),
     ("minimize_fixs", minimize_fixs),
     ("fix_conversion", fix_conversion),
     ("contract", contract),
     ("specialize_recursive_functions",specialize_recursive_functions),
     ("eliminate_explicit_records", eliminate_explicit_records),
     ("print_opt_lambda_expression", print_opt_lambda_expression),
     ("print_attop_atbot_expression", print_attop_atbot_expression),
     ("print_drop_regions_expression", print_drop_regions_expression),
     ("print_drop_regions_expression_with_storage_modes", print_drop_regions_expression_with_storage_modes),
     ("print_call_explicit_expression", print_call_explicit_expression),
     ("print_physical_size_inference_expression", print_physical_size_inference_expression),
     ("disable_atbot_analysis", disable_atbot_analysis),
     ("print_K_normal_forms", print_K_normal_forms),
     ("debug_which_at", debug_which_at),
     ("enhanced_atbot_analysis", enhanced_atbot_analysis),
     ("region_profiling", region_profiling),
     ("show_region_flow_graph", show_region_flow_graph),
     ("warn_on_escaping_puts", warn_on_escaping_puts),
     ("chat", chat),
     ("delay_assembly", delay_assembly),
     ("eliminate_polymorphic_equality", eliminate_polymorphic_equality),
     ("print_types", print_types),
     ("print_regions", print_regions),
     ("print_word_regions", print_word_regions),
     ("print_effects", print_effects), 
     ("print_type_name_stamps", print_type_name_stamps), 
     ("all_multiplicities_infinite", all_multiplicities_infinite), 
     ("optimiser", optimiser),
     ("raggedRight", raggedRight),
     ("print_all_program_points", print_all_program_points),
     ("all_multiplicities_infinite", all_multiplicities_infinite), 
     ("log_to_file", log_to_file),  (*true => generate a .log file*)
     ("garbage_collection", garbage_collection),
     ("DEBUG_COMPILER", DEBUG_COMPILER)]

end (* Directory *)


                        (******************************************)
                        (*        structure Menu                  *)
                        (*                                        *)
                        (* Defines an abstract menu type and      *)
                        (* operations for building and interacting*)
                        (* with menus.                            *)
                        (******************************************)

structure Menu: sig
                    val add_flag: string * string * bool ref -> unit
                    val add_flag_to_menu: string list* string * string * bool ref -> unit
                    val add_string_to_menu: string list* string * string * string ref -> unit
		    val add_int_to_menu: string list* string * string * int ref -> unit
                    val interact: unit -> unit
                  end =
struct

  datatype attribute = SWITCH of bool ref | VALUE of unit -> string

  datatype menu = 
    DISPLAY of item list
  | BUTTON of {r : bool ref, 
               text1: string, below1: menu, 
               text2: string, below2: menu}
  | ACTION of unit -> unit
  | NOMENU

  withtype item = {text: string, attr: attribute, below: menu} 
  
  
  fun empty NOMENU = true
    | empty _ = false;

  fun max(i:int, j: int) = if i>=j then i else j
  fun pad width text = StringCvt.padRight #"." width text;
  fun help () = outLine "\n\n***Try again\n"
  
  val menu = ref(DISPLAY[]) ; (* updated later*)
    
  fun mk_toggle (text, b: bool ref) = {text= text, attr = SWITCH b, below = NOMENU}


  fun mk_header text below : item = {text=text,attr=VALUE(fn _ => ""),below=below}

  (* Overwrite TextIO.inputLine to old definition *)
  val inputLine = 
     fn stream => (case TextIO.inputLine stream of SOME s => s | NONE => "")

  (*read_string r () = read a string from TextIO.stdIn.  If the input is some
   string in quotes, read_string assigns it to the ref r (and sets the global
   (whooa!) ref u_or_q_from_read_string is to false), and returns.  If the
   input is `u' or `quit', read_string does not update r, sets
   u_or_q_from_read_string to false, and returns.  For other inputs
   read_string gives an error message and lets the user try again.*)

  val u_or_q_from_read_string = ref false
  fun read_string r () =
      (u_or_q_from_read_string := false ;
       outLine "<string in double quotes>, Up (u), or Quit (quit): >" ;
       let val cs = explode (inputLine TextIO.stdIn)
	   val cs = StringCvt.skipWS getc cs
       in
	 case cs of 
	   [] => (help () ; read_string r ())
	 | #"q" :: #"u" :: #"i" :: #"t" :: _  => u_or_q_from_read_string := true
	 | #"u" :: _  => u_or_q_from_read_string := true
	 | #"\"" (*"*) :: _  => 
           (case scan_string getc cs
	      of SOME(s,_) => r := s 
	       | NONE => (help () ; read_string r ()))
	 | _ => (help () ; read_string r ())
       end)

  fun read_int r () =
    (outLine "<number> or up (u): >";
     let val cs = explode(inputLine TextIO.stdIn)
         val cs = StringCvt.skipWS getc cs
     in case cs 
	  of [] => (help(); read_int r ())
	   | #"q" :: #"u" :: #"i" :: #"t" :: _  => ()
	   | #"u" :: _  => ()
	   | _ => (case Int.scan StringCvt.DEC getc cs 
		     of SOME(i,_) => r:= i 
		      | _ => (help(); read_int r ()))
     end)

  fun mk_string_action(r: string ref, text) =
    {text = text, attr = VALUE (fn () => "(" ^ quote(!r) ^ ")"),
     below = ACTION (read_string r)};

  fun mk_int_action(r: int ref, text) =
    {text = text, attr = VALUE(fn _ => Int.toString(!r)),
     below = ACTION (read_int r)};


  fun add_flag (key: string, menu_txt: string, flag: bool ref) =
        (Directory.add_bool_entry(key,flag);
         case !menu of
           DISPLAY l =>
             (case rev l of
                ({text = "Extensions", attr,below = DISPLAY l2} :: rest)=>
                   menu:= DISPLAY(rev({text = "Extensions", attr=attr, 
                                       below = DISPLAY(l2 @[mk_toggle(menu_txt, flag)])}::rest))
              | rest' => 
                   menu:= DISPLAY(rev({text = "Extensions", attr=VALUE(fn () => ""), 
                                       below = DISPLAY([mk_toggle(menu_txt, flag)])}::rest'))
  
             )
          | _ => die "add_flag.menu not DISPLAY."
        );

  fun add_path(path : string list, add_menu: menu -> menu, menu : menu) : menu =
    case path 
      of [] => add_menu menu
       | (txt::path') =>
	let fun extend [] : item list = [mk_header txt (add_path(path',add_menu,NOMENU))] (* insert new header *)
	      | extend ((item as {text,attr,below})::items) =
	       if text=txt then {text=text,attr=attr,below=add_path(path',add_menu,below)} :: items
	       else item :: extend items 
	in case menu 
	     of DISPLAY l => DISPLAY (extend l)
	      | BUTTON{r, text1, below1, text2, below2} =>
	       if text1=txt then
		 BUTTON{r=r, text1=text1, below1=add_path(path',add_menu, below1),text2=text2,below2=below2}
	       else if text2=txt then
		 BUTTON{r=r, text1=text1, below1=below1,text2=text2,below2=add_path(path',add_menu,below2)}
	       else die "add_path.menu is BUTTON."
	      | NOMENU => DISPLAY (extend [])
	      | _ => die "add_path.menu not DISPLAY, BUTTON, or NOMENU." 
	end

  fun add_flag_to_menu(path : string list, key: string, menu_text: string, flag: bool ref): unit =
    let 
      fun add_flag menu =
         case menu of 
           DISPLAY l=> DISPLAY(l @ [mk_toggle(menu_text, flag)])
         | NOMENU => DISPLAY[mk_toggle(menu_text,flag)]
         | _ => die "add_flag_to_menu.menu not DISPLAY or NOMENU."
    in
      Directory.add_bool_entry(key,flag);
      menu:= add_path(path,add_flag,!menu)
    end

  fun add_string_to_menu(path : string list, key: string, menu_text: string, str: string ref): unit =
    let 
      fun add_string menu =
         case menu of 
           DISPLAY l=> DISPLAY(l @ [mk_string_action(str,menu_text)])
         | NOMENU => DISPLAY[mk_string_action(str,menu_text)]
         | _ => die "add_string_to_menu.menu not DISPLAY or NOMENU."
    in
      Directory.add_string_entry(key,str);
      menu:= add_path(path,add_string,!menu)
    end

  fun add_int_to_menu(path : string list, key: string, menu_text: string, integer: int ref): unit =
    let 
      fun add_int menu =
         case menu of 
           DISPLAY l=> DISPLAY(l @ [mk_int_action(integer,menu_text)])
         | NOMENU => DISPLAY[mk_int_action(integer,menu_text)]
         | _ => die "add_int_to_menu.menu not DISPLAY or NOMENU."
    in
      Directory.add_int_entry(key,integer);
      menu:= add_path(path,add_int,!menu)
    end

                    (******************)
                    (* Printing menus *)
                    (******************)
 
  fun display_lines(lines:  {text: string,
                             attr: attribute,
                             below: menu}list) : unit = 
    let 
           val width = foldl
                       (fn ({text, ...}, acc:int) => max(size text, acc))
                       0
                       (lines)
  
           fun outText (n,text, s: string) =
	         outLine("\t" ^ Int.toString n ^ "\t" ^ pad width text ^ s)
           
           fun display_line (n, {text, attr, below}) =
             case (attr, below) of
               (SWITCH(ref true), NOMENU)     => outText(n, text, " on")
             | (SWITCH(ref true), _     )     => outText(n, text, " on >>>")
             | (SWITCH(ref false), NOMENU )   => outText(n, text, " off")
             | (SWITCH(ref false), _ )        => outText(n, text, " off (>>>)")
             | (VALUE show, NOMENU)           => outText(n, text, " " ^ show())
             | (VALUE show, _ )               => outText(n, text, " " ^ show() ^ " >>>")
  
           fun loop(n,[]) =()
           |   loop(n,line::rest) = (display_line(n, line); loop(n+1, rest))
                   
     in
       loop(0,lines);
       outLine "\nToggle line (t <number>), Activate line (a <number>), Up (u), or Quit (quit): "
    end;
  
  fun blanks n =
    let 
      fun loop  n = if n<= 0 then [] else  " " :: loop(n-1)
    in
      concat(loop n)
    end;
  
                        (********************)
                        (* Printing buttons *)
                        (********************)

  fun show_button{r: bool ref, text1: string, below1: menu, 
                               text2: string, below2: menu} : unit=
    let 
  
        (* Bottons are printed as illustrated by the following example:
  
             - - - - - - - - - -   ====================
               Manual Settings     | Read from Script |
               off (>>>)           |      on >>>      |
             - - - - - - - - - -   ====================
     
         Toggle (t), Activate chosen (a), Up (u), or Quit (quit)
       *)
  
        fun mk_odd n: int = if n mod 2 = 0 then n+1 else n
        fun hrepeat unit n = if n <=0 then [] else unit :: hrepeat unit (n-1);
        fun center text width = (* pad 'text' with blanks on the left and the right to 
                                achieve string with total width 'width' *)
            let val left_part = blanks ((width - size text) div 2) ^ text 
            in left_part ^ blanks(width - size left_part) 
            end
        fun show_choice (b: bool, text, below)  =
            let val botton_width = mk_odd (size text + 4) 
                val rule = concat(hrepeat (if b then "==" else "- ") (botton_width div 2)
                                   @ [(if b then "=" else "-")])
                val lrule = if b then "|" else " "
                fun centerline text = concat[lrule, " ",  center text (botton_width-4), " ", lrule]
                val status = if b then "on" ^
                         (if empty below then "" else " >>>")
                             else "off"^
                              (if empty below then "" else " (>>>)")
                val text_line = centerline text
                val status_line = centerline status
            in 
               (rule, text_line, status_line, rule)
            end
        val descend_is_possible = !r andalso not(empty below1) orelse
                                  not(!r) andalso not(empty below2)
        val bot1 as (l11,l12,l13,l14) = show_choice(!r, text1, below1)
        val bot2 as (l21,l22,l23,l24) = show_choice(not(!r), text2, below2)
  
    in
       outLine ("\t" ^ l11 ^ "  " ^ l21);
       outLine ("\t" ^ l12 ^ "  " ^ l22);
       outLine ("\t" ^ l13 ^ "  " ^ l23);
       outLine ("\t" ^ l14 ^ "  " ^ l24);
       outLine( "\n\nToggle (t)" ^ (if descend_is_possible then ", Activate chosen (a), Up (u), or Quit (quit)"
                                else ", Up (u), or Quit (quit)"))
    end;
       
  
  fun show_menu menu = case menu of
    DISPLAY l => display_lines l
  | BUTTON bot => show_button bot
  | _ => ();
  
  
               (************************************************)
               (* Printing an overview of the entire menu tree *)
               (************************************************)

  (* this code uses leading newlines whereas normal
     printing of menus uses trailing newlines in output *)
  
  val delta = 4
  fun outLineInd indent s =
     (outLine ""; (*start new line*)
      print(blanks indent ^ s)
     )
  fun show_full_menu  indent menu = case menu of
    DISPLAY l => NewList.app (show_full_item indent) l  
  | BUTTON{r, text1, below1, text2, below2}=>
      (outLineInd (indent) ("BUTTON ON: " ^ text1);
      show_full_menu (indent+delta) below1;
      outLineInd (indent) ("BUTTON OFF: " ^ text2);
      show_full_menu (indent+delta) below2)
  | ACTION _ => print " fn"
  | NOMENU => ()
  and show_full_item indent {text: string, attr = VALUE show, below} =
        (outLineInd indent (text ^ " " ^ show());
         show_full_menu(indent+delta)below)
    | show_full_item indent {text, attr = SWITCH _, below} =
        (outLineInd indent (text ^ "(switch)");
         show_full_menu(indent+delta)below);
  
  val show_full_menu_r = ref(fn () => 
       (outLine "\n----------------------------------------------------\n";
        show_full_menu 5 (!menu); 
        outLine "\n----------------------------------------------------\n"))
  
                 (*************************************************)
                 (* Menu commands (entered by user interactively) *)
                 (*************************************************)
  
  datatype cmd =   TOGGLE of int 
                 | TOGGLE_BOT 
                 | ACTIVATE_BOT 
                 | ACTIVATE of int 
                 | ACTIVATE_OR_TOGGLE of int
                 | UP 
                 | QUIT 
                 | HELP;
  
  fun read_display_cmd(): cmd =
    (print "\n>";
     let val cs = explode(inputLine TextIO.stdIn)
         val cs = StringCvt.skipWS getc cs
     in case cs of
          [] => HELP
        | #"q" :: #"u" :: #"i" :: #"t" :: _ => QUIT
        | #"u" :: _ => UP
        | #"a" :: cs => (case Int.scan StringCvt.DEC getc cs 
			   of SOME(i, _) => ACTIVATE i
			    | _ => HELP)
        | #"t" :: cs => (case Int.scan StringCvt.DEC getc cs 
			   of SOME(i, _) => TOGGLE i
			    | _ => HELP)
        | _ =>  (case Int.scan StringCvt.DEC getc cs
		   of SOME(n,_) => ACTIVATE_OR_TOGGLE n
		    | _ => HELP)
     end);
  
  fun read_button_cmd () : cmd =
        (print "\n>";
	 let val cs = explode(inputLine TextIO.stdIn)
	     val cs = StringCvt.skipWS getc cs
	 in case cs of
	   [] => HELP
	 | #"q" :: #"u" :: #"i" :: #"t" :: _ => QUIT
	 | #"u" :: _ => UP
	 | #"a" :: l' => ACTIVATE_BOT
	 | #"t" :: l' => TOGGLE_BOT
	 | _ => HELP
	 end);
  
  
                         (**********************************************)
                         (* Auxiliary functions for constructing menus *)
                         (**********************************************)

  val noop_attr : attribute = VALUE (fn () => "")
  fun mk_header text below  : item= 
              {text = text, attr = VALUE(fn _ => ""), below = below};
  fun mk_toggled_header text r below = 
              {text = text, attr = SWITCH r, below = below};
  fun mk_button(r, text1, below1, text2, below2) =
               BUTTON{r = r, text1 = text1, below1 = below1, text2 = text2, below2 = below2}
  fun mk_simple_button(r, text1, text2) = 
               mk_button(r, text1,  NOMENU, text2  , NOMENU);
  fun mk_action (text, f: unit -> unit) = 
               {text = text, attr = VALUE(fn _ => ""), below = ACTION f}
  
  fun read_int_list r () =
    (outLine "<type an int list, e.g. [4,3]> or up (u): >";
     let
       val s = inputLine TextIO.stdIn
       val cs = explode s
     in
       case cs
	 of [] => (help(); read_int_list r ())
	  | #"u" :: _  => ()
	  | #"q" :: #"u" :: #"i" :: #"t" :: _  => ()
	  | #"["::_ => (case scan_list (Int.scan StringCvt.DEC) getc cs
			  of SOME(l',_) => (r := l')
			   | _ => (help(); read_int_list r ()))
	  | _ => (help(); read_int_list r ())
     end)

  fun read_int_pair_list r () =
    (outLine "<type an int pair list of region variables,\n\
	  \e.g. [(formal reg. var. at pp.,letregion bound reg. var.)]> or up (u): >" ;
     let
       val s = inputLine TextIO.stdIn
       val cs = explode s
     in
       case cs
	 of [] => (help(); read_int_pair_list r ())
	  | #"u" :: _  => ()
	  | #"q" :: #"u" :: #"i" :: #"t" :: _  => ()
	  | #"["::_ => (case scan_list (scan_pair (Int.scan StringCvt.DEC) (Int.scan StringCvt.DEC)) getc cs
			  of SOME(l',_) => (r := l')
			   | NONE => (help(); read_int_pair_list r ()))
	  | _ => (help(); read_int_pair_list r ())
     end)

    fun mk_int_list_action(r: int list ref, text) =
              {text = text, 
	       attr = VALUE 
	       (fn _ => (List.string 
			 (fn i => (Int.toString i))
			 (!r))),
	       below = ACTION (read_int_list r)};

    fun mk_int_pair_list_action(r: (int*int) list ref, text) =
              {text = text, 
	       attr = VALUE 
	       (fn _ => (List.string 
			 (fn (i1, i2) => 
			  "(" ^ Int.toString i1 ^ "," ^ Int.toString i2 ^ ")")
			 (!r))),
	       below = ACTION (read_int_pair_list r)};
  
                     (*********************************)
                     (*  Construction of the Kit Menu *)
                     (*********************************)


  (*0. Project*)

    val project_item : item =
          mk_header "Project"
	  (DISPLAY
	   [mk_string_action (project_file_name, "Set project file name"),
	    {text = "Compile and link project", attr = noop_attr, 
	     below = ACTION (fn () => !build_project_ref(!project_file_name))}])

  (*1. Printing of intermediate forms*)

    val printing_of_intermediate_forms_item : item =
          mk_header "Printing of intermediate forms"
	  (DISPLAY
	   [mk_toggle ("print optimised lambda expression", print_opt_lambda_expression),
	    mk_toggle ("print atbot expression", print_attop_atbot_expression),
	    mk_toggle ("print drop regions expression", print_drop_regions_expression),
	    mk_toggle ("print drop regions expression with storage modes", print_drop_regions_expression_with_storage_modes),
	    mk_toggle ("print physical size inference expression", print_physical_size_inference_expression),
	    mk_toggle ("print call-explicit expression", print_call_explicit_expression)])
    

  (*2. Layout*)

    val layout_item : item = mk_header "Layout"
          (DISPLAY
	   [mk_toggle ("print types", print_types),
	    mk_toggle ("print effects", print_effects),
	    mk_toggle ("print regions ", print_regions),
	    mk_toggle ("print in K-Normal Form", print_K_normal_forms),
	    mk_toggle ("ragged right margin in pretty-printing", raggedRight),
	    mk_int_action (colwidth, "text width"),
	    mk_toggle ("print type name stamps and attributes", print_type_name_stamps),
	    mk_toggle ("print word regions ", print_word_regions)
	    ])


  (*3. Control*)

  local
    val multiplicity_inference_items : item list =
          [mk_toggle ("all multiplicities infinite (for POPL 96)", all_multiplicities_infinite)]
    val storage_mode_analysis_items : item list =
          [mk_toggle ("all storage modes attop  (for POPL 96)", disable_atbot_analysis)]
    val optimiser_item : item = mk_header "Optimiser"
      (DISPLAY
       [mk_toggle ("optimiser", optimiser),
	mk_toggle ("statistics after optimisation", statistics_after_optimisation),
	mk_toggle ("minimize fixs", minimize_fixs), 	
	mk_toggle ("fix conversion", fix_conversion), 
	mk_toggle ("contract", contract), 
	mk_toggle ("specialize recursive functions", specialize_recursive_functions), 
	mk_toggle ("eliminate explicit records", eliminate_explicit_records),
	mk_int_action (maximum_inline_size, "maximum inline size"),
	mk_int_action (maximum_specialise_size, "maximum specialise size")
	])
  in
    val control_item : item = mk_header "Control"
          (DISPLAY
	   ([mk_toggle ("chat", chat),
             mk_toggle ("delay_assembly", delay_assembly),
	    optimiser_item,
	    {text = "print entire menu", attr = noop_attr,
	     below = ACTION (!show_full_menu_r)},
	    {text = "print all flags and variables", attr = noop_attr,
	     below = ACTION Directory.show_script_entries}]
	   @ multiplicity_inference_items
	   @ storage_mode_analysis_items
	   @ [mk_toggle ("warn on escaping put effects", warn_on_escaping_puts),
	      mk_string_action (c_libs, "link with library")]))
  end (*local*)


  (*4. File menu*)

  val file_item : item = mk_header "File"
    let val script = ref "kit.script"
    in DISPLAY [mk_toggle ("Log to file", log_to_file),
                mk_toggle ("Delete target files", delete_target_files),
		mk_string_action (path_to_runtime, "Runtime system (no profiling)"),
		mk_string_action (path_to_runtime_prof, "Runtime system (profiling)"),
		{text = "Read a script file", attr = noop_attr, 
		 below = ACTION (fn () => (read_string script () ;
					   if !u_or_q_from_read_string then () 
					   else Directory.readScript (!script)))},
		{text = "Read it again", attr = VALUE(fn _ => "(" ^ quote (!script) ^ ")"),
		 below = ACTION (fn _ => (Directory.readScript (!script)))}]
    end

  (*5. Profiling menu*)

  local 
    val program_points_item =
          {text = "Program points", attr = VALUE(fn _ => ""),
	   below = mk_button (print_all_program_points, "Print all program points", NOMENU,
			      "Print some program points", 
			      DISPLAY [mk_int_list_action
				       (program_points, "Program points to print")])}
    fun show_flag true = "on" 
      | show_flag false = "off"
    fun toggle_ref r = r := not (! r)
  in
    val profiling_item : item = mk_header "Profiling" 
          (DISPLAY
	   [{text = "region profiling",
	     attr = VALUE (fn () => show_flag (!region_profiling)),
	     below = ACTION (fn () => toggle_ref region_profiling)},
	    mk_toggle ("show region flow graph and generate .vcg file", show_region_flow_graph),
	    mk_int_pair_list_action(region_paths, "paths between two nodes in region flow graph")
(*TODO 31/03/1997 20:37. tho.:
            , program_points_item
*)
	    ])
  end


  (*6. Debug Kit*)
  
  local
    local
      val debug_elabdec : menu = DISPLAY 
	    [mk_toggle ("debug types ", DEBUG_TYPES),
	     mk_toggle ("debug type variables ", DEBUG_TYVARS),
	     mk_toggle ("debug elaboration of flexible records ", DEBUG_FLEXRECORDS),
	     mk_toggle ("debug static objects ", DEBUG_STATOBJECTS)]
    in
      val front_end_item : item  =
	    {text = "Front End", attr = VALUE(fn _ => ""),
	     below = DISPLAY 
	       [mk_toggle ("debug lexing ", DEBUG_LEXING),
		mk_toggle ("debug parsing ", DEBUG_PARSING),
		{text = "debug elabdec", attr = SWITCH DEBUG_ELABDEC,
		 below = debug_elabdec},
		mk_toggle ("debug elabtopdec ", DEBUG_ELABTOPDEC),
		mk_toggle ("debug environments ", DEBUG_ENVIRONMENTS),
		mk_toggle ("debug error printing ", DEBUG_ERRORPRINT),
		mk_toggle ("debug evaluation of Core declarations ", DEBUG_EVALDEC),
		mk_toggle ("debug evaluation of Modules declarations ", DEBUG_EVALTOPDEC)]}
    end (*local*)
    val lambda_item =
        {text = "Lambda", attr = VALUE(fn _ => ""),
	 below =
	 DISPLAY
	 [mk_toggle ("debug decision trees ", DEBUG_DECISIONTREE),
	  mk_toggle ("debug match compiler ", DEBUG_MATCHCOMPILER)]}

    val backend_item : item = mk_header "Backend" NOMENU
  in
    val debug_kit_item : item = mk_header "Debug Kit"
          (DISPLAY 
	    [front_end_item,
	     lambda_item,
	     mk_toggle ("debug compiler ", DEBUG_COMPILER),
	     mk_toggle ("debug optimiser ", DEBUG_OPTIMISER),
	     mk_toggle ("debug which_at (storage mode analysis)", debug_which_at),
	     backend_item])
  end (*local*)


  (*7. Compile an sml file*)
  (*8. Compile it again*)

  local fun comp_current_source_file () = !comp_ref (!current_source_file)
  in
    val compile_an_sml_file_item : item =
          {text = "Compile an sml file", attr = noop_attr, 
	   below = ACTION (fn () => (read_string current_source_file () ;
				     if !u_or_q_from_read_string then () else
				     comp_current_source_file ()))}
    val compile_it_again_item : item =
          {text = "Compile it again",
	   attr = VALUE (fn () => "(" ^ quote (!current_source_file) ^ ")"),
	   below = ACTION comp_current_source_file}
  end (*local*)

  (* 9. Garbage Collection *)
  val gc_item = mk_toggle("Garbage Collection", garbage_collection)

  (* ---------------------------------------------------------------------- *)
  (*    Initializing menu.                                                  *)
  (* ---------------------------------------------------------------------- *)

  val _ =  menu := (DISPLAY [(*0.*) project_item,
			     (*1.*) printing_of_intermediate_forms_item,
			     (*2.*) layout_item,
			     (*3.*) control_item,
			     (*4.*) file_item,
			     (*5.*) profiling_item,
			     (*6.*) debug_kit_item,
                             (*7.*) compile_an_sml_file_item,
			     (*8.*) compile_it_again_item
			     (*, (*9.*) gc_item*) 
			     ]) ;

                         (**************************)
                         (* interact               *)
                         (**************************)

  exception Quit; 

  fun interact () = interact0 ()
        handle Quit => ()
	     | Crash.CRASH => (outLine "*** CRASH raised *" ; interact ()) 
	     | IO.Io _ => (outLine ("*** IO.Io raised *"); interact ())
	     | Overflow => (outLine "*** Overflow raised *"; interact ())
	     | e => (outLine ("*** Uncaught exception " ^ General.exnName e ^ " ***");
		     outLine ("Exn message: " ^ General.exnMessage e);
		     outLine "I shall reraise it...";
		     raise e)

  and interact0 () = inter ([], !menu)
  
                        (*************************************************)
                        (* inter(path,menu):                             *)
                        (*                                               *)
                        (*    the read-eval loop of the interaction      *)
                        (*    'path' is the path from the root to 'menu' *)
                        (*    and is used for printing                   *)
                        (*************************************************)

  and inter (path, menu : menu) : unit = 
    (case menu of
       DISPLAY l => 
        (show_path path;
         outLine "";
         show_menu menu; 
         case read_display_cmd () : cmd of
           ACTIVATE n =>
	     ((case NewList.nth (l,n) of
		{below = NOMENU, ...} => 
		  (outLine("***Nothing to activate ");
		   inter(path,menu))
	      | {below, attr = SWITCH(ref false), ...} =>
		  (outLine ("***Switch is disabled - use  `t" ^ Int.toString n
			    ^ "' to toggle menu, if that is what you want");
		  inter(path, menu) )
	      | {text, below, ...} => (inter(text::path, below); inter(path, menu))
		  ) handle Subscript => (outLine"***Number out of range" ; inter(path, menu)))
          | TOGGLE n =>
	      ((case NewList.nth (l,n) of
		  {attr = SWITCH r, ...} => 
		    (r:= not(!r); inter(path, menu))
		| {attr = VALUE _ , ...} => 
		    (outLine("***Nothing to toggle ");
		     inter(path, menu) )
                    ) handle Subscript =>
		               (outLine "***Number out of range" ;
				help(); inter(path, menu)))
          | ACTIVATE_OR_TOGGLE n =>
	      ((case NewList.nth (l,n) of 
		  {attr = SWITCH(r as ref false), ...} =>
		    (* assume toggle *) 
		    (r := not (!r) ; inter (path, menu))
		| {attr = SWITCH(r as ref true), below = NOMENU, ...} =>
		    (* assume toggle *) 
		    (r := not (!r) ; inter (path, menu))
		| {attr = VALUE _ , below, text,...} => 
		    (* assume activate *)
		    (inter (text::path, below) ; inter(path, menu))
		| _ => (help () ; inter (path, menu))
		    ) handle Subscript =>
		               (outLine "***Number out of range" ;
				help() ; inter (path, menu)))
          | UP => (case path of (*ignore u when at top-level menu*)
		     [] => inter (path,menu)
		   | _ => ())
          | QUIT => raise Quit
          | _ => (help () ; inter (path,menu)))
     | BUTTON (bot as {r: bool ref, text1: string, below1: menu,
		                    text2: string, below2: menu}) => 
        (show_path path;
         outLine "";
         show_menu menu; 
         case read_button_cmd () : cmd of
           TOGGLE_BOT => 
             (r := not (!r);
              inter(path, menu))
         | ACTIVATE_BOT => 
             if !r then
	       if not (empty below1) then inter (text1::path,below1)
	       else outLine "***Nothing to activate"
	     else 
	       if not (empty below2) then inter (text2::path,below2)
	       else outLine "***Nothing to activate"
         | UP => ()
         | QUIT => raise Quit
         | _ => (help(); inter(path,menu)))
     | ACTION f => f ()
     | NOMENU => ())

  and show_path (l : string list) = 
        outLine(List.stringSep "\t" "" "/" (fn s => s) (rev l));

end (*structure Menu*)

exception ParseScript = ParseScript.ParseScript
type state = Directory.state
val get_state = Directory.get_state
val reset_state = Directory.reset_state
val is_on = Directory.is_on
val turn_on = Directory.turn_on
val turn_off = Directory.turn_off
val lookup_flag_entry = Directory.lookup_flag_entry
val add_string_entry = Directory.add_string_entry
val get_string_entry = Directory.get_string_entry
val lookup_string_entry = Directory.lookup_string_entry
val lookup_int_entry = Directory.lookup_int_entry
val read_script = Directory.readScript
val show_script_entries = Directory.show_script_entries
val add_flag = Menu.add_flag   
val add_flag_to_menu = Menu.add_flag_to_menu
val add_string_to_menu = Menu.add_string_to_menu
val add_int_to_menu = Menu.add_int_to_menu
val interact = Menu.interact

end (* functor Flags *)  
   
  

structure profRegInf =
  struct
    val b = ref false
  end
